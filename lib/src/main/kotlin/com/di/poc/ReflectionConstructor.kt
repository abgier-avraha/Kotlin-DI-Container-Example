/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.di.poc

class ReflectionConstructor {

    companion object {
        fun <TServiceType>getInstanceFromType(
            type: java.lang.Class<TServiceType>,
            singletonDependencies: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            transientDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedCache: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            ): TServiceType? {

            // Check if type is registered as a singleton dep
            val matchingSingleton = singletonDependencies.get(type as java.lang.Class<Any>) as TServiceType
            if (matchingSingleton != null) {
                return matchingSingleton
            }

            // Check if type is registered as a transient dep
            val matchingTransient = transientDependencies.get(type as java.lang.Class<Any>) as java.lang.Class<TServiceType>?
            if (matchingTransient != null) {
                val newInstance = ReflectionConstructor.constructFromClass(
                    matchingTransient,
                    singletonDependencies,
                    transientDependencies,
                    scopedDependencies,
                    scopedCache)
                return newInstance
            }
            
            // Check if type is a cached scoped dep
            val matchingScopedCached = scopedCache.get(type as java.lang.Class<Any>) as TServiceType
            if (matchingScopedCached != null) {
                return matchingScopedCached
            }

            // Check if type is registered as a scoped dep
            val matchingScoped = scopedDependencies.get(type as java.lang.Class<Any>) as java.lang.Class<TServiceType>?
            if (matchingScoped != null) {
                val newInstance = ReflectionConstructor.constructFromClass(
                    matchingScoped,
                    singletonDependencies,
                    transientDependencies,
                    scopedDependencies,
                    scopedCache)
                    
                scopedCache.put(type as java.lang.Class<Any>, newInstance as java.lang.Object)
                return newInstance
            }
            return null
        }

        fun <TServiceType>constructFromClass(
            serviceClass: java.lang.Class<TServiceType>,
            singletonDependencies: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            transientDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedCache: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            ): TServiceType? {

            val existingInstance = ReflectionConstructor.getInstanceFromType<TServiceType>(
                serviceClass,
                singletonDependencies,
                transientDependencies,
                scopedDependencies,
                scopedCache)

            if (existingInstance != null) {
                return existingInstance as TServiceType
            }

            // Retrieve constructor function
            val constructors = serviceClass.getConstructors()
            if (constructors.size < 1) {
                throw Exception("No constructor found for ${serviceClass}")
            }

            val primaryConstructor = serviceClass.getConstructors()[0]

            // Prepare list of args from existing services
            val params = mutableListOf<Any>()
            for (param in primaryConstructor.getParameters()) {
                val param = ReflectionConstructor.getInstanceFromType<Any>(
                    param.type as java.lang.Class<Any>,
                    singletonDependencies,
                    transientDependencies,
                    scopedDependencies,
                    scopedCache)
                params.add(param as Any)
            }

            return primaryConstructor.newInstance(*params.toTypedArray()) as TServiceType
        }

        inline fun <reified TServiceType, reified TService>construct(
            singletonDependencies: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            transientDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedDependencies: MutableMap<java.lang.Class<Any>, java.lang.Class<Any>>,
            scopedCache: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            ): TServiceType? where TService : TServiceType {
            return ReflectionConstructor.constructFromClass(
                TService::class.java,
                singletonDependencies,
                transientDependencies,
                scopedDependencies,
                scopedCache) as TServiceType
        }
    }
}
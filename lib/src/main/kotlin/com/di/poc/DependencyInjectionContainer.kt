/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.di.poc

// TODO: how could this fit in a framework with lifecycles for instances?

class DependencyInjectionContainer {
        // Key is class and vaue is instance
        var singletonDependencies = mutableMapOf<Class<*>, Any>()

        // Key is class and value is a factory
        var transientDependencies = mutableMapOf<Class<*>, Class<*>>()

        // Key is class and value is a factory
        var scopedDependencies = mutableMapOf<Class<*>, Class<*>>()

        fun createScope(): ServiceScope {
                return ServiceScope(this)
        }

        inline fun <reified TServiceType> injectSingleton(
                        instance: Any
        ): DependencyInjectionContainer {
                this.singletonDependencies.put(TServiceType::class.java, instance)
                return this
        }

        inline fun <reified TServiceType, reified TService> injectSingleton():
                        DependencyInjectionContainer where TService : TServiceType {
                // Construct singleton from generic arg
                // Singletons can not contain transient or scoped dependencies
                val instance =
                                ReflectionConstructor.construct<TServiceType, TService>(
                                                this.singletonDependencies,
                                                mutableMapOf<Class<*>, Class<*>>(),
                                                mutableMapOf<Class<*>, Class<*>>(),
                                                mutableMapOf<Class<*>, Any>()
                                )

                this.singletonDependencies.put(TServiceType::class.java, instance as Any)
                return this
        }

        inline fun <reified TServiceType, reified TService> injectTransient():
                        DependencyInjectionContainer {
                this.transientDependencies.put(TServiceType::class.java, TService::class.java)
                return this
        }

        inline fun <reified TServiceType, reified TService> injectScoped():
                        DependencyInjectionContainer {
                this.scopedDependencies.put(TServiceType::class.java, TService::class.java)
                return this
        }

        fun <TServiceType> remove(serviceType: Class<TServiceType>) {
                this.singletonDependencies =
                                this.singletonDependencies
                                                .filterKeys { it::class.java == serviceType }
                                                .toMutableMap()
                this.transientDependencies =
                                this.transientDependencies
                                                .filterKeys { it::class.java == serviceType }
                                                .toMutableMap()
                this.scopedDependencies =
                                this.scopedDependencies
                                                .filterKeys { it::class.java == serviceType }
                                                .toMutableMap()
        }

        inline fun <reified TServiceType> remove() {
                val serviceType = TServiceType::class.java
                this.remove(serviceType)
        }
}

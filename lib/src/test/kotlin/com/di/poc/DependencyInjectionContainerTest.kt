/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.di.poc

import java.io.ByteArrayOutputStream
import java.io.PrintStream
import kotlin.test.AfterTest
import kotlin.test.BeforeTest
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith
import kotlin.test.assertNotEquals

class DependencyInjectionContainerTest {

    private var outContent = ByteArrayOutputStream()
    private var errContent = ByteArrayOutputStream()
    private var originalOut = System.out
    private var originalErr = System.err

    @BeforeTest
    fun setUpStreams() {
        System.setOut(PrintStream(this.outContent))
        System.setErr(PrintStream(errContent))
    }

    @AfterTest
    fun restoreStreams() {
        System.setOut(originalOut)
        System.setErr(originalErr)
    }

    @Test
    fun canInjectAndProvide() {
        val container = DependencyInjectionContainer()

        container.injectTransient<ILogger, Logger>().injectScoped<IService, Service>()

        val scope = container.createScope()
        val service = scope.provide<IService>()

        assertEquals("Service", service.someMethod())
        service.logger.configure(service)

        service.logger.info("Test")
        assertEquals("com.di.poc.Service::Test\n", this.outContent.toString())
    }

    @Test
    fun canInjectAndReplace() {
        val container = DependencyInjectionContainer()

        container
                .injectTransient<ILogger, Logger>()
                .injectScoped<IService, Service>()
                .injectScoped<IService, SomeService>()

        val scope = container.createScope()
        val service = scope.provide<IService>()

        assertEquals("SomeService", service.someMethod())
    }

    @Test
    fun throwsWhenProvidingRemoved() {
        val container = DependencyInjectionContainer()

        container.injectTransient<ILogger, Logger>().injectScoped<IService, Service>()

        container.remove<IService>()

        val scope = container.createScope()
        assertFailsWith<Exception>(
                message = "Instance for interface com.di.poc.IService could not be fetched",
                block = { scope.provide<IService>() }
        )
    }

    @Test
    fun singletonDependencyEquality() {
        val container = DependencyInjectionContainer()

        container.injectSingleton<Dummy, Dummy>()

        val scope = container.createScope()
        val serviceA = scope.provide<Dummy>()
        val serviceB = scope.provide<Dummy>()
        assertEquals(serviceA, serviceB)
    }

    @Test
    fun scopedDependencyEquality() {
        val container = DependencyInjectionContainer()

        container.injectTransient<ILogger, Logger>().injectScoped<IService, Service>()

        val scope = container.createScope()
        val serviceA = scope.provide<IService>()
        val serviceB = scope.provide<IService>()
        assertEquals(serviceA, serviceB)
    }

    @Test
    fun transientDependencyInequality() {
        val container = DependencyInjectionContainer()

        container.injectTransient<ILogger, Logger>().injectTransient<IService, Service>()

        val scope = container.createScope()
        val serviceA = scope.provide<IService>()
        val serviceB = scope.provide<IService>()
        assertNotEquals(serviceA, serviceB)
    }
}

class Dummy {}

interface ILogger {
    fun <T : Any> configure(forInstance: T)
    fun info(message: String)
}

class Logger : ILogger {
    private var prefix = ""

    override fun <T : Any> configure(forInstance: T) {
        this.prefix = forInstance::class.java.getName()
    }

    override fun info(message: String) {
        println("${this.prefix}::${message}")
    }
}

interface IService {
    val logger: ILogger

    fun someMethod(): String
}

class Service : IService {
    override val logger: ILogger

    constructor(logger: ILogger) {
        this.logger = logger
    }

    override fun someMethod(): String {
        return "Service"
    }
}

class SomeService : IService {
    override val logger: ILogger

    constructor(logger: ILogger) {
        this.logger = logger
    }

    override fun someMethod(): String {
        return "SomeService"
    }
}

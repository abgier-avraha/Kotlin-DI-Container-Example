/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package abgier.di.poc

// TODO: how could this fit in a framework with lifecycles for instances?

class DependencyInjectionContainer {
    // Key is class and vaue is instance
    val singletons = mutableMapOf<java.lang.Class<Any>, java.lang.Object>()

    // Key is class and value is a factory
    val singletonFactories = mutableMapOf<java.lang.Class<Any>, (java.lang.Class<Any>) -> java.lang.Object>()

    // Key is tuple of parent class and service class with instance as value
    val singletonFactoryCache = mutableMapOf<Pair<java.lang.Class<Any>, java.lang.Class<Any>>, java.lang.Object>()


    inline fun <reified TServiceInterface>injectFactory(noinline instanceFactory: (java.lang.Class<Any>) -> TServiceInterface): DependencyInjectionContainer {
        this.singletonFactories.put(TServiceInterface::class.java as java.lang.Class<Any>, instanceFactory as (java.lang.Class<Any>) -> java.lang.Object)
        return this
    }
    
    inline fun <reified TServiceInterface>inject(instance: java.lang.Object): DependencyInjectionContainer {
        this.singletons.put(TServiceInterface::class.java as java.lang.Class<Any>, instance as java.lang.Object)
        return this
    }

    inline fun <reified TServiceInterface, reified TService>inject(): DependencyInjectionContainer where TService : TServiceInterface {
        val instance = ReflectionConstructor.construct<TServiceInterface, TService>(this.singletons, this.singletonFactories, this.singletonFactoryCache)
        this.singletons.put(TServiceInterface::class.java as java.lang.Class<Any>, instance as java.lang.Object)
        return this
    }

    inline fun <reified TServiceInterface>provide() : TServiceInterface {
        val serviceInterface = TServiceInterface::class.java
        val instance = ReflectionConstructor.getInstanceFromType<TServiceInterface>(serviceInterface, this.singletons, this.singletonFactories, this.singletonFactoryCache)

        if (instance == null) {
            throw Exception("Instance of ${serviceInterface} could not be fetched")
        }

        return instance as TServiceInterface
    }

    inline fun <reified TServiceInterface, reified TParent>provideFactory() : TServiceInterface {
        val serviceInterface = TServiceInterface::class.java
        val parentClass = TParent::class.java
        val instance = ReflectionConstructor.getInstanceFromType<TServiceInterface>(serviceInterface, parentClass, this.singletons, this.singletonFactories, this.singletonFactoryCache)

        if (instance == null) {
            throw Exception("Instance of ${serviceInterface} could not be fetched")
        }

        return instance
    }

    // TODO: .remove<TServiceInterface>
    // TODO: .remove(service)
    // TODO: also remove and references in to the interface in the caches
}

class ReflectionConstructor {

    companion object {
        fun <TServiceType>getInstanceFromType(
            type: java.lang.Class<TServiceType>,
            singletons: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            singletonFactories: MutableMap<java.lang.Class<Any>, (java.lang.Class<Any>) -> java.lang.Object>,
            singletonFactoryCache: MutableMap<Pair<java.lang.Class<Any>, java.lang.Class<Any>>, java.lang.Object>,
            ): TServiceType? {

            // Check if type is registered as a singleton
            val matchingSingleton = singletons.get(type as java.lang.Class<Any>)
            if (matchingSingleton != null) {
                return matchingSingleton as TServiceType
            }

            return null
        }

        fun <TServiceType>getInstanceFromType(
            type: java.lang.Class<TServiceType>,
            parentClass: java.lang.Class<*>,
            singletons: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            singletonFactories: MutableMap<java.lang.Class<Any>, (java.lang.Class<Any>) -> java.lang.Object>,
            singletonFactoryCache: MutableMap<Pair<java.lang.Class<Any>, java.lang.Class<Any>>, java.lang.Object>,
            ): TServiceType? {
            
            // Check if type is registered as a singleton
            val matchingSingletonOrCache = ReflectionConstructor.getInstanceFromType(type, singletons, singletonFactories, singletonFactoryCache)
            if (matchingSingletonOrCache != null) {
                return matchingSingletonOrCache as TServiceType
            }

            // Check if type is registered as a factory type and is cached
            val matchingFactoryCache = singletonFactoryCache.get(Pair<java.lang.Class<Any>, java.lang.Class<Any>>(type as java.lang.Class<Any>, parentClass as java.lang.Class<Any>))
            if (matchingFactoryCache != null) {
                return matchingFactoryCache as TServiceType
            }

            val matchingFactory = singletonFactories.get(type as java.lang.Class<Any>)
            if (matchingFactory != null) {
                val newFactoryObject = matchingFactory.invoke(parentClass as java.lang.Class<Any>)
                singletonFactoryCache.put(Pair<java.lang.Class<Any>, java.lang.Class<Any>>(type, parentClass as java.lang.Class<Any>), newFactoryObject)
                return newFactoryObject as TServiceType
            }
            
            return null
        }

        inline fun <reified TServiceInterface, reified TService>construct(
            singletons: MutableMap<java.lang.Class<Any>, java.lang.Object>,
            singletonFactories: MutableMap<java.lang.Class<Any>, (java.lang.Class<Any>) -> java.lang.Object>,
            singletonFactoryCache: MutableMap<Pair<java.lang.Class<Any>, java.lang.Class<Any>>, java.lang.Object>
            ): TServiceInterface? where TService : TServiceInterface {
            val serviceClass = TService::class.java

            val existingInstance = ReflectionConstructor.getInstanceFromType<TService>(serviceClass, singletons, singletonFactories, singletonFactoryCache)

            if (existingInstance != null) {
                return existingInstance as TServiceInterface
            }

            // Retrieve constructor function
            val constructors = serviceClass.getConstructors()
            if (constructors.size < 1) {
                throw Exception("No constructor found for ${serviceClass}")
            }

            val primaryConstructor = serviceClass.getConstructors()[0]

            // Prepare list of args from existing services
            val params = mutableListOf<Any>()
            for (param in primaryConstructor.getParameters()) {
                val param = ReflectionConstructor.getInstanceFromType<Any>(param.type as java.lang.Class<Any>, serviceClass, singletons, singletonFactories, singletonFactoryCache)
                params.add(param as Any)
            }

            return primaryConstructor.newInstance(*params.toTypedArray()) as TServiceInterface
        }
    }
}
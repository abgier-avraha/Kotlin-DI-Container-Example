/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.di.poc

import kotlin.test.Test
import kotlin.test.assertTrue
import kotlin.test.assertFailsWith

class DependencyInjectionContainerTest {
    
    @Test fun canInjectAndProvide() {
        val container = DependencyInjectionContainer()
        
        container
            .injectTransient<ILogger, Logger>()
            .injectSingleton<IService, Service>()

        val service = container.provide<IService>()

        assertTrue(service != null)
        assertTrue(service.logger != null)

        assertTrue(service.someMethod() == "Service")
        service.logger.configure(service)

        // TODO: assertion and stdout
        service.logger.info("Test")
    }

    @Test fun canInjectAndReplace() {
        val container = DependencyInjectionContainer()
        
        container
            .injectTransient<ILogger, Logger>()
            .injectSingleton<IService, Service>()
            .injectSingleton<IService, SomeService>()

        val service = container.provide<IService>()

        assertTrue(service.someMethod() == "SomeService")
    }

    @Test fun throwsWhenProvidingRemoved() {
        val container = DependencyInjectionContainer()
        
        container
            .injectTransient<ILogger, Logger>()
            .injectSingleton<IService, Service>()

        container.remove<IService>()

        assertFailsWith<Exception>(
            message = "Instance for interface com.di.poc.IService could not be fetched",
            block = {
                container.provide<IService>()
            }
        )
    }

    @Test fun singletonDependencyEquality() {
        val container = DependencyInjectionContainer()
        
        container
            .injectTransient<ILogger, Logger>()
            .injectSingleton<IService, Service>()

        val serviceA = container.provide<IService>()
        val serviceB = container.provide<IService>()
        assertTrue(serviceA == serviceB)
    }

    @Test fun transientDependencyInequality() {
        val container = DependencyInjectionContainer()
        
        container
            .injectTransient<ILogger, Logger>()

        val loggerA = container.provide<ILogger>()
        val loggerB = container.provide<ILogger>()
        assertTrue(loggerA != loggerB)
    }
}

class Dummy {

}

interface ILogger {
    fun <T : Any>configure(forInstance: T)
    fun info(message: String)
}


class Logger : ILogger {
    private var prefix = ""

    override fun <T : Any>configure(forInstance: T) {
        this.prefix = forInstance::class.java.getName()
    }

    override fun info(message: String) {
        println("${this.prefix}::${message}")
    }
}

interface IService {
    val logger: ILogger

    fun someMethod(): String
}

class Service : IService {
    override val logger: ILogger

    constructor(logger: ILogger) {
        this.logger = logger
    }

    override fun someMethod(): String
    {
        return "Service"
    }
}

class SomeService : IService {
    override val logger: ILogger

    constructor(logger: ILogger) {
        this.logger = logger
    }

    override fun someMethod(): String
    {
        return "SomeService"
    }
}